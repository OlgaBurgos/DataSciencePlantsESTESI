---
title: "Valoración del riesgo invasor en la Península Ibérica"
author: "Erola Fenollosa, Olga Burgos, Gianluca Arauz, Ramón Diaz"
date: "July 10, 2018"
output:
  html_document:
    toc: true
    number_sections: true
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(Encoding="UTF-8")
options(tikzDefaultEngine = "xetex")
```

# Especies invasoras - Un problema global {.tabset}
-Las especies invasoras suponen una problema muy importante para la biodiversidad. De hecho, se consideran la segunda mayor amenaza a la biodiversidad, después de la pérdida de hábitat. Según la ICN (GIAN -> Qué es la ICN? Primero decir qué és y luego poner las siglas), las especies invasoras son:

>“**Especie exótica invasora**”: especie exótica que se establece en un ecosistema o hábitat natural o seminatural; es un agente de cambio y amenaza la diversidad biológica nativa. (UICN, 2000)

##¿Por qué son invasoras?
Existen diversas hipótesis que tratan de explicar los motivos por los cuales algunas especies se convierten en invasoras. La hipótesis mayoritaria es que la falta de enemigos naturales en el nuevo habitat donde la invasora llega, le permite crecer sin control invirtiendo menos en compuestos y estrategias defensivas. Esta es la *Enemy Release Hypothesis*.

Otros autores postulan la regla del 10. De diez especies exóticas que llegan a un nuevo terreno, una se convierte en invasora. Esta hipótesis se basa en el azar y el hecho de que algunas comunidades son mas fáciles de ser invadidas que otras.

Una tercera corriente postula que hay ciertos rasgos que proporcionan a las especies invasoras mayores posibilidades para serlo. Por ejemplo, grandes inversiones en dispersión de semillas, ciclos de vida cortos o crecimiento clonal son algunos de los rasgos propuestos, como los que definen a un "buen invasor".

Ninguna de estas hipótesis és excluyente, por lo que los factores determinantes del éxito invasor podría ser una combinación de aspectos de las tres corrientes. En cualquier caso, resulta evidente que un mejor conocimiento de los factores que determinan si una especie podría convertirse en invasora, sería vital para las políticas de conservación de la biodiversidad, pues la prevención es la acción más económica para erradicar una especie invasora.

Por eso nosotros queremos comprobar hasta qué punto la similitud con el marco climático de una región, en nuestro caso la Península Íbérica, puede favorecer a la invasión biológica y de esta manera deducir en qué países o regiones, debido a este solapamiento, deben implementarse medidas de prevención mayores.

# Preguntas de partida y definiciones iniciales {.tabset}

## Preguntas
Si las invasiones son exitosas por coincidencia del clima, ¿qué especies podrían aclimatarse en la península ibérica y son por tanto potencialmente invasoras?

¿Las especies invasoras actuales en la península ibérica cumplen esa hipótesis de coincidencia del clima?
Si las condiciones climáticas en la península cambiasen en el contexto del cambio climático, ¿el número de especies potencialmente invasoras sería mayor, menor o igual? ¿El cambio climático podría potenciar la amenaza invasora?

Teniendo en cuenta el origen de las especies potencialmente invasoras y los movimientos globales de mercancías y personas, ¿qué invasiones son mas probables? ¿Con qué países deberíamos endurecer las políticas de comercio de especies?

¿Por qué superficie se extenderían las especies potencialmente invasoras en la península? ¿Cuánto es su daño potencial?

Teniendo en cuenta las condiciones climáticas en la península, ¿qué otros países de Europa podrían ser susceptibles a la invasión debido a similitudes con el marco climático de España y Portugal?

## Definiciones
>**Marco climatico Ibérico(MCI)**: Espacio multidimensional definido por los valores de diferentes variables bioclimáticas georreferenciados dentro de la Península Ibérica.

>**Variable bioclimática**: Variable descriptora ambiental considerada determinante para el crecimiento, desarrollo y reproducción de la biosfera.

>**Nicho climático**: Espacio multidimensional definido por los valores de diferentes variables bioclimáticas de los puntos de presencia de una especie.

>**Especie potencialmente invasora en la Peninsula Ibérica**: Especie cuyo nicho climático está comprendido dentro del MCI.

# Paquetes necesarios {.tabset}
Antes de empezar, instalaremos los paquetes necesarios a lo largo del documento.
```{r echo=3:5, results='hide', message=FALSE, warning=FALSE} 
# GIAN -> El " results='hide', message=FALSE, warning=FALSE " sirve para que este chunk no nos escriba el output de cargar la librerias en el HTML. Cosa que no aporta nada y queda feillo en el HTML.
list.of.packages <- c("DataExplorer", "raster", "dismo", "plotly", "fmsb", "factoextra", "MASS","ggbiplot","vqv","readr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
```

Una vez disponibles todos los paquetes, podemos cargar las respectivas librerías.
```{r echo=2:, results='hide', message=FALSE, warning=FALSE}
# setwd("C:/Users/Desktop/DataSciencePlantsESTESI") 
library(raster)
library(sp)
library(dismo)
library(readr)
library(ggplot2)
library(plotly)
library(MASS)
library(fmsb)
library(devtools)
library(ggbiplot)
library(factoextra)
```

# Delimitación del MCI {.tabset}
En primer lugar descargaremos el *dataset* de la base de datos globales [WorldClim](http://worldclim.org/). Elegiremos las [19 variables bioclimáticas](http://worldclim.org/bioclim) con una resolución geográfica de 2.5' (minutos de grado). El argumento `var = "bio"` de la función `getData()` reclama dichas variables bioclimáticas. El portal WorldClim incluye variables climáticas teniendo en cuenta un contexto de cambio climático. Más adelante se pueden testear las diferencias. Las variables referentes a la temperatura están multiplicadas por 10.

```{r,fig.align='center',out.extra='angle=90'}
worldata <- getData("worldclim",var="bio", res=2.5)

plot (worldata$bio1,
   main = "Mapa de la temperatura media (BIO1) global",
   xlab = "Longitud (ºC)",
   ylab = "Latitud (ºC)")
```

Los datos de `worldata` se encuentran en formato rasterizado. Ahora debemos seleccionar la extensión correspondiente a la Península Ibérica. Pasaremos la ventana de latitudes y longitudes que enmarcan la Península Ibérica a la función `extent()`: $(-10º W, 4ºE)$ y $(36ºN, 44ºN)$. Seguidamente, recortaremos la extensión `e` sobre los datos `worldata` utilizando la función `crop()`.

```{r, fig.align='center', out.extra='angle=90'}
e <- extent(-10, 4, 36, 44)
s.crop <- crop(worldata, e)

plot (s.crop$bio1,
   main = "Mapa de la temperatura media (BIO1) en la Península Ibérica",
   xlab = "Longitud (ºC)",
   ylab = "Latitud (ºC)")
```
El archivo `s.crop` también se encuentra en formato rasterizado. Para trabajar más cómodamente, construiremos un *dataframe* llamado `marcoclim`, definiendo los nombres de las variables bioclimáticas:

```{r}

marcoclim <- as.data.frame(s.crop)

BIOs <- paste('BIO', (1:19), sep = '')
names(marcoclim) <- BIOs

```

Finalmente, exportamos el *dataframe* `marcoclim` en formato `*.csv`.
```{r}
write.csv(marcoclim, file="Datos/MarcoClim2.5.csv")
```

# Análisis exploratorio {.tabset}
Para no perder tiempo descargando cada vez los datos del marcoclim y preparandolos, cargamos directamente el csv generado:
```{r}
marcoclim<- read_csv("Datos/MarcoClim2.5.csv", 
    col_types = cols(X1 = col_skip()))

head(marcoclim)
```

Antes de continuar trabajando, necesitamos hacernos una idea de cómo son los datos, para ello realizamos un pequeño **análisis exploratorio** y **data wrangling**.
```{r}
library(DataExplorer)
marcoclim <- marcoclim[complete.cases(marcoclim),] # Elimina NA's.
summary(marcoclim) #Resumen de cada variable
plot_str(marcoclim) #Estructura de los datos
plot_histogram(marcoclim) 
cor(marcoclim) # Idea de la correlación de unas variables con otras
plot_correlation(marcoclim) #Para visualizar mejor la correlación.
```

Ahora, podemos representar los datos obtenidos, dependiendo de las variables que nos interesa mostrar:

Por ejemplo,generar un gráfico con temperatura media anual y precipitación media anual.


```{r, fig.cap= "Temperatura y Precipitación en la Península Ibérica"}
plot(marcoclim$BIO1~marcoclim$BIO12, pch=19, col="lightblue", xlab="Precipitación Anual (mm)", ylab="Temperatura anual media (ºC x10)") 
```

Para generar un gráfico de densidad con estas mismas variables usamos la función `kde2d`(kernel density two dimensions) del paquete `MASS`

```{r, fig.cap = "Grafico de densidad de Temperatura y Precipitación en la Península Ibérica"}
str(marcoclim)
plot(marcoclim$BIO12 ~ marcoclim$BIO1, col = "blue")
d <- density(marcoclim$BIO1) # returns the density data 
plot(d)

dens <- kde2d(marcoclim$BIO1, marcoclim$BIO12, n=300, lims = c(0,200,0,1400))
image(dens)
filled.contour(dens,
               color.palette=colorRampPalette(c('gray94','blue','yellow','red','darkred')),
               xlab= "Annual Mean Temperature (ºC)",
               ylab= "Annual Precipitation (mm)", main = "Marco Climático Ibérico")

```

# DESCARTAR VARIABLES MUY CORRELACIONADAS (opcional) {.tabset}
Al trabajar con 19 variables, algunas producto lineal de otras como hemos visto en el gráfico de correlación, estamos trabajando con información redundante. Podemos basarnos en el criterio `VIF` (factores de inflación de varianza), un enfoque simple para identificar la colinealidad entre las variables explicativas para descartar algunas y probar el modelo mas adelante con todas las variables y con solo las seleccionadas. 

Esto se describe en este [blog](https://www.r-bloggers.com/collinearity-and-stepwise-vif-selection/)

Definimos la función de cálculo y selección de variables con el `VIF`
```{r}
vif_func<-function(in_frame,thresh=10,trace=T,...){
  
  library(fmsb)
  
  if(any(!'data.frame' %in% class(in_frame))) in_frame<-data.frame(in_frame)
  
  #get initial vif value for all comparisons of variables
  vif_init<-NULL
  var_names <- names(in_frame)
  for(val in var_names){
    regressors <- var_names[-which(var_names == val)]
    form <- paste(regressors, collapse = '+')
    form_in <- formula(paste(val, '~', form))
    vif_init<-rbind(vif_init, c(val, VIF(lm(form_in, data = in_frame, ...))))
  }
  vif_max<-max(as.numeric(vif_init[,2]), na.rm = TRUE)
  
  if(vif_max < thresh){
    if(trace==T){ #print output of each iteration
      prmatrix(vif_init,collab=c('var','vif'),rowlab=rep('',nrow(vif_init)),quote=F)
      cat('\n')
      cat(paste('All variables have VIF < ', thresh,', max VIF ',round(vif_max,2), sep=''),'\n\n')
    }
    return(var_names)
  }
  else{
    
    in_dat<-in_frame
    
    #backwards selection of explanatory variables, stops when all VIF values are below 'thresh'
    while(vif_max >= thresh){
      
      vif_vals<-NULL
      var_names <- names(in_dat)
      
      for(val in var_names){
        regressors <- var_names[-which(var_names == val)]
        form <- paste(regressors, collapse = '+')
        form_in <- formula(paste(val, '~', form))
        vif_add<-VIF(lm(form_in, data = in_dat, ...))
        vif_vals<-rbind(vif_vals,c(val,vif_add))
      }
      max_row<-which(vif_vals[,2] == max(as.numeric(vif_vals[,2]), na.rm = TRUE))[1]
      
      vif_max<-as.numeric(vif_vals[max_row,2])
      
      if(vif_max<thresh) break
      
      if(trace==T){ #print output of each iteration
        prmatrix(vif_vals,collab=c('var','vif'),rowlab=rep('',nrow(vif_vals)),quote=F)
        cat('\n')
        cat('removed: ',vif_vals[max_row,1],vif_max,'\n\n')
        flush.console()
      }
      
      in_dat<-in_dat[,!names(in_dat) %in% vif_vals[max_row,1]]
      
    }
    
    return(names(in_dat))
    
  }
  
}
```

Aplicamos la función a nuestros datos. Ésta va calculando los `VIF`, y en cada cálculo quita el que tiene mayor valor hasta quedarse con valores de VIF por debajo del umbral (en nuestro caso hasta quedarnos con 5 valores)
```{r}
vif_func(in_frame=marcoclim,thresh=5,trace=T) 
```


# Reducción de dimensionalidad mediante PCA {.tabset}
Para describir de forma reducida el marco climático Ibérico realizamos una reducción de dimensiones mediante un `Análisis de Componentes principales`:

Si los datos no están cargados podemos llamarlos:
```{r}
marcoclim<- read_csv("Datos/MarcoClim2.5.csv", 
    col_types = cols(X1 = col_skip()))

#View(marcoclim)
marcoclim <- marcoclim[complete.cases(marcoclim),] # Elimina NA

```

Realizamos la `PCA` con los dos datos utilizando la función `prcomp` que R ya tiene interna.

```{r}
pcaclim <- prcomp(marcoclim, center = TRUE, scale. = TRUE) 
print(pcaclim)
plot(pcaclim, type = "l")
summary(pcaclim)
plot(pcaclim$x[,1],pcaclim$x[,2], col = "lightblue")
```

Obtenemos la desviación estándar y la proporción de la varianza de cada una de los componentes principales basándose en las 19 componentes climáticas.
Con el compontente principal 1 y 2 se explica un **75,44%** de la variabilidad, suficiente para continuar trabajando.

Además, podemos calcular el peso de cada variable bioclimática para cada componente principal, con `pca$rotarion`


```{r}
pcaclim$rotation[,1]
pcaclim$rotation[,2]
```


Para facilitar el entendimiento de la contribución de cada una de las variables en el análisis de componentes principales, Podemos generar plots con las funciones:
-`fviz_pca_var`
-`ggbiplot`


```{r}
fviz_pca_var(pcaclim,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)  



g <- ggbiplot(pcaclim, obs.scale = 1, var.scale = 1, 
               ellipse = TRUE, alpha=0.1, 
              circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', 
               legend.position = 'top')
print(g)
```
También podríamos realizar una `PCA` solo con las variables que `VIF` < 5(opcional)
```{r}
marcoclimVIF <- marcoclim[,c(2,3,8,9,13,15)]

pcaclim2 <- prcomp(marcoclimVIF, center = TRUE, scale. = TRUE) 
print(pcaclim2)
plot(pcaclim2, type = "l")
summary(pcaclim2)
```

# Obtención de datos de países y proyección sobre el MCI {.tabset}
Llegados a este punto, pretendemos evaluar si las condiciones climáticas de los diferentes países del mundo se parecen a las de España, con el fin de determinar después especies que podrían encontrar condiciones favorables en nuestro país actuando como invasoras. Por eso proyectamos los datos del marco climático de estos países sobre el nuestro.

Cargamos los datos del marco climatico ibérico:
```{r}
marcoclim<- read_csv("Datos/MarcoClim2.5.csv", 
    col_types = cols(X1 = col_skip()))

#View(marcoclim)
marcoclim <- marcoclim[complete.cases(marcoclim),] # Elimina NA

```

Preparamos los datos de la Península Ibérica de los dos primeros componentes:
```{r}
e <- pcaclim$x[,1:2]
edf <- as.data.frame(e)
edf$pais <- "Spain" #Añadimos una varaible de Pais, con todas las etiquetes "Spain"
head(edf)
```


Descargamos los datos del WordClim (ya hecho previamente en el #3)
```{r}
#Download the WorldClim Data
worldata <- getData("worldclim",var="bio", res=2.5)
plot(worldata$bio1, main =  "Temperatura media anual mundial (ºC x10)")
```

En: https://www.gis-blog.com/r-raster-data-acquisition, encontramos como se realiza la descarga y recorte de los paises. Para llamar a un pais concreto se usa la nomenclatura de tres letras definida en: http://kirste.userpage.fu-berlin.de/diverse/doc/ISO_3166.html. Hay una base de datos con los nombres y codigos de los 241 paises que incluye la lista. Podemos importar esos datos:
```{r}
CountryCodes <- read_delim("Datos/CountryCodes.csv", 
    ";", escape_double = FALSE, trim_ws = TRUE)

#A3 son los codigos para descargar el pais
```


Descargamos los límites políticos de un país con la función:
```{r}
denmark <- getData('GADM', country='DNK', level=0)
plot(denmark)
s<- crop(worldata, denmark)
s2 <- mask(s, denmark)
s2<-as.matrix(s2)
marcoclim.denmark <- as.data.frame(s2)
names(marcoclim.denmark) <- c("BIO1","BIO2","BIO3","BIO4", "BIO5", "BIO6", "BIO7", "BIO8", "BIO9",
                 "BIO10","BIO11","BIO12","BIO13", "BIO14", "BIO15", "BIO16", "BIO17", "BIO18", "BIO19")

marcoclim.denmark <- marcoclim.denmark[complete.cases(marcoclim.denmark),]

```



Proyectamos estos valores sobre el PCA del marco climático ibérico. Generamos la variable país, con el nombre de la etiqueta del mismo. Además combinamos los dos data frames, con los datos de PC1 y PC2 de España y el país seleccionado.
```{r}
i <- predict (pcaclim, newdata = marcoclim.denmark) 
i <- i[,1:2]

idf <- as.data.frame(i) 
idf$pais <- "Din" 

df <- rbind(edf,idf) 

```


Generamos un gráfico para visualizar el grado de solapamiento de ambas nubes de puntos:

```{r}
ggplot(df, aes(x=PC1, y=PC2, col=pais)) + geom_point()

```


Solapamos dos gráficos de densidad para visualizar el grado de solapamiento de ambas nubes de puntos:
```{r}
# PARA HACER UN SOLO GRAFICO DE DENSIDAD CON TODOS LOS DATOS SERIA ASí
dens <- kde2d(df$PC1, df$PC2, n=300, lims = c(-20,10,-10,10))
image(dens)
filled.contour(dens,
               color.palette=colorRampPalette(c('gray94','blue','yellow','red','darkred')),
               xlab= "PC1",
               ylab= "PC2", main = "Contraste de marcos climaticos")

# AHORA SOLO ESPAÑA:
dense <- kde2d(edf$PC1, edf$PC2, n=300, lims = c(-12,7,-10,10))
image(dense)
filled.contour(dense,
               color.palette=colorRampPalette(c('gray94','blue','yellow','red','darkred')),
               xlab= "PC1",
               ylab= "PC2", main = "Marco climático Ibérico")

#AHORA SOLO EL PAIS PROYECTADO:
densi <- kde2d(idf$PC1, idf$PC2, n=300, lims = c(-12,7,-10,10))
image(densi)
filled.contour(densi,
               color.palette=colorRampPalette(c('gray94','blue','yellow','red','darkred')),
               xlab= "PC1",
               ylab= "PC2", main = "Marco climático Ibérico del pais proyectado")

```


# Determinación del riesgo invasor {.tabset}
##Coincidencia climática versus MCI 
Con el fin de determinar el grado de solapamiento climático de un país cualquiera respecto a España, creamos hipervolúmenes a partir de los dos primeros componentes principales, que explican un 75% de la varianza, y los comparamos, obteniendo así el volumen compartido y otros índices de similitud.

Para ello, utilizaremos el paquete "hypervolume"(Bibliografia--> 3 artículos!!!)

```{r}

install.packages("hypervolume")
library(hypervolume)

install.packages("alphahull")
library (alphahull)

```
# DEFINE THE STATIC ENVIRONMENT
Una vez obtenidos los datos del marco climático español, realizado el análisis de componentes principales y creado un data frame con los resultados de ésta, definiremos el primer hipervolumen.
Seguidamente recordamos la forma de realizar los pasos mencionados.


```{r}
worldata <- getData("worldclim",var="bio", res=10)
e <- extent(-10,4,36,44)
s.crop <- crop(worldata, e)
a<-as.matrix(s.crop)
marcoclim <- as.data.frame(a)
names(marcoclim) <- c("BIO1", "BIO2", "BIO3", "BIO4", "BIO5", "BIO6", "BIO7", "BIO8", "BIO9",
                      "BIO10", "BIO11", "BIO12", "BIO13", "BIO14", "BIO15", "BIO16", "BIO17", "BIO18", "BIO19")
marcoclim <- marcoclim[complete.cases(marcoclim),]
pcaclim <- prcomp(marcoclim, center = TRUE, scale. = TRUE) 
e <- pcaclim$x[,1:2]
edf <- as.data.frame(e)
edf$pais <- "Spain"

```

El hipervolumen de n-dimensiones es una medida que generaliza el concepto de volumen a espacios de dimensión superior a tres. 
En nuestro caso, utilizaremos un Gaussian KDE(kernel density estimation) en el que todos los puntos contribuyen a la densidad de la probabilidad global.

En la función "hypervolume_gaussian", por defecto se le asigna un umbral del 95% asegurando la máxima probabilidad en la estimación de la densidad.
Además generaremos un plot para visualizar el hipervolumen en el que se genera un centroide.

```{r}
hv1sp = hypervolume_gaussian(data=subset(df,pais=="Spain")[1:2730, 1:2])
plot(hv1sp,show.contour=TRUE,contour.kde.level=0.01)

```

## DINAMIC ENVIRONMENT
El siguiente paso será generar un hipervolumen para cada uno de los países que testaremos frente el marco climático ibérico español. Por ejemplo creando un hipervolúmen con los datos de Dinamarca.

```{r}
hv2dn = hypervolume_gaussian(data=subset(df,pais=="Din")[1:238, 1:2])
plot(hv2dn,show.contour=TRUE,contour.kde.level=0.01)
```

Una vez obtenidos los dos hipervolúmenes, utilizaremos la función "hypervolume_set" y "hypervolume_overlap_statistics".
La primera genera valores estadísticos computando la intersección, la unión y los componentes únicos(diferencia) de los hipervolúmenes, que podemos observar llamando la función "get_volume"

La segunda función calcula los métricos de superposición para los dos hipervolúmenes.Printa directamente índices de similitus entre los dos volúmenes:
-accard Jaccard similarity (volume of intersection of 1 and 2 divided by volume of union of 1 and 2)
-sorensen Sorensen similarity (twice the volume of intersection of 1 and 2 divided by volume of 1 plus volume of 2)
-frac_unique_1 Unique fraction 1 (volume of unique component of 1 divided by volume of 1))
-frac_unique_2 Unique fraction 2 (volume of unique component of 2 divided by volume of 2))

Además calcularemos la distancia entre centroides usando la función "hypervolume_distance"

```{r}
setH <-hypervolume_set(hv1sp, hv2dn, check.memory = FALSE)
volumes<-get_volume(setH)
overl<- hypervolume_overlap_statistics(setH)

dist<- hypervolume_distance(hv1sp, hv2dn, type='centroid')
```

##OUTPUTS
Con los datos estadísticos obtenidos anteriormente, podemos generar una lista para facilitar la visualización. 
```{r}
values <- c(volumes, overl, dist)
```
## COUNTRY LOOPING
En este punto, crearemos un algoritmo para poder testear la similitud del marco climático de cada país más agilmente respecto al de España.
El marco climático español será un valor fijo en este algoritmo, mientras que los inputs seran los datos climáticos de los diferentes países a testear. 



Queremos cuantificar el grado de solapamiento de las nubes de puntos descritas por los puntos de los dos países, el receptor (España) y el proyectado.
Hay que crear ciertos metricos para la determinación de el grado de riesgo de invasión. 

# Significación por *bootstraping* {.tabset}
Realizar una ANOVA con permutaciones por Bootstraping: contraste de la distribución de etiquetas a l'azar con la distribuci?n real de etiquetas. ?La assignaci?n podria haber sido al azar?
Si el resultado resulta significativo, hay diferenciaci?n del espacio climatico y por lo tanto las especies del pais proyectado no podrian sobrevivir en Espa?a. 

COMO HACERLO EN R??  PENDIENTE

# Significación por Test de Permutación {.tabset}

# Grado de solapamiento desde el receptor y desde el proyectado {.tabset}

PENDIENTE!!!

# Otros? {.tabset}

PENDIENTE!!!

# OBTENCION DATOS DE ESPECIES INVASORAS MUNDIALES. ORIGEN Y PRESENCIA {.tabset}

Turbelin et al. 2017, utilizan datos de http://www.iucngisd.org/gisd/ y de https://www.cabi.org/isc/. para determinar los patrones de distribucion de especies invasoras, en CABI existen datasets de cada una de las especies ex?ticas invasoras. Descargamos estos datos para una lista de plantas, recogen pa?s donde la planta est? presente, latitud longitud, si es nativa o introducida, etc.  Los uniremos entre si? . 

# Bibliograf?a {.tabset}

# Sitios web {.tabset}

https://worldclim.org/bioclim
https://www.cabi.org/isc/.
https://www.r-bloggers.com/collinearity-and-stepwise-vif-selection/
https://tgmstat.wordpress.com/2013/11/28/computing-and-visualizing-pca-in-r/
https://www.gis-blog.com/r-raster-data-acquisition http://kirste.userpage.fu-berlin.de/diverse/doc/ISO_3166.html.
https://stackoverflow.com/questions/31272695/calculate-probability-of-point-on-2d-density-surface
https://rstudio-pubs-static.s3.amazonaws.com/330387_5a40ca72c3b14824acedceb7d34618d1.html

https://stats.stackexchange.com/questions/63447/integrating-kernel-density-estimator-in-2d

# Artículos y libros {.tabset}

Turbelin, Anna J., Malamud, Bruce D., Francis, Robert A.Mapping the global state of invasive alien species: patterns of invasion and policy responses.*Global Ecology & Biogeography*, September 2016.

Davison, A. C. & Hinkley, D. V. (1997) Bootstrap Methods and Their Applications. Cambridge University Press, Cambridge. ISBN 0-521-57391-2