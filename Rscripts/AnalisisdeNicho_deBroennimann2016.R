#################################################################################################
############################## load functions and packages ######################################
#################################################################################################

install.packages("ecospat")
install.packages("biomod2")
install.packages("ade4")
install.packages("adehabitatHS")
install.packages("MASS")
install.packages("gam")

library(ecospat)
library(biomod2)
library(ade4)
library(adehabitatHS)
library(MASS)
library(gam)

install.packages("rworldmap")
library(rworldmap)

setwd("C:/R/NicheModelling/Broenimann/2")
source("niche.overlap.functions.R")
source("occ.prep.functions.R")

#####################################################################################
############################## load functions  ######################################
#####################################################################################


## Written by Olivier Broennimann. Departement of Ecology and Evolution (DEE). 
## University of Lausanne. Switzerland. October 09.
##
## DESCRIPTION
##
## functions to perform measures of niche overlap and niche equivalency/similarity tests as described in Broennimann et al. (submitted)
## 
## list of functions:
##
## grid.clim(glob,glob1,sp,R) 
## use the scores of an ordination (or SDM predictions) and create a grid z of RxR pixels 
## (or a vector of R pixels when using scores of dimension 1 or SDM predictions) with occurrence densities
## Only scores of one, or two dimensions can be used 
## sp= scores for the occurrences of the species in the ordination, glob = scores for the whole studies areas, glob 1 = scores for the range of sp 
##
## niche.overlap(z1,z2,cor)
## calculate the overlap metrics D and I (see Warren et al 2008) based on two species occurrence density grids z1 and z2 created by grid.clim
## cor=T correct occurrence densities of each species by the prevalence of the environments in their range
##
## niche.equivalency.test(z1,z2,rep)
## runs niche equivalency test(see Warren et al 2008) based on two species occurrence density grids
## compares the observed niche overlap between z1 and z2 to overlaps between random niches z1.sim and z2.sim.
## z1.sim and z2.sim are built from random reallocations of occurences of z1 and z2
## rep is the number of iterations
##
## niche.similarity.test(z1,z2,rep)
## runs niche similarity test(see Warren et al 2008) based on two species occurrence density grids
## compares the observed niche overlap between z1 and z2 to overlaps between z1 and random niches (z2.sim) in available in the range of z2 (z2$Z) 
## z2.sim have the same patterns as z2 but their center are randomly translatated in the availabe z2$Z space and weighted by z2$Z densities
## rep is the number of iterations
##
## plot.niche(z,title,name.axis1,name.axis2)
## plot a niche z created by grid.clim. title,name.axis1 and name.axis2 are strings for the legend of the plot
##
## plot.contrib(contrib,eigen)
## plot the contribution of the initial variables to the analysis. Typically the eigen vectors and eigen values in ordinations
##
## plot.overlap.test(x,type,title)
## plot an histogram of observed and randomly simulated overlaps, with p-values of equivalency and similarity tests. 
## x must be an object created by niche.similarity.test or niche.equivalency.test.
## type is either "D" or "I". title is the title of the plot

##################################################################################################

grid.clim<-function(glob,glob1,sp,R){
  
  # glob: global background dataset for the whole study area, 
  # glob1: background for sp1
  # sp: occurrence dataset
  # R: resolution of the grid
  l<-list()
  
  if (ncol(glob)>2) stop("cannot calculate overlap with more than two axes")
  
  if(ncol(glob)==1){ 											#if scores in one dimension (e.g. LDA,SDM predictions,...)
    xmax<-max(glob[,1])
    xmin<-min(glob[,1])
    sp.dens<-density(sp[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0) 		# calculate the density of occurrences in a vector of R pixels along the score gradient
    # using a gaussian kernel density function, with R bins.
    glob1.dens<-density(glob1[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0)	# calculate the density of environments in glob1
    x<-sp.dens$x 											# breaks on score gradient
    z<-sp.dens$y*nrow(sp)/sum(sp.dens$y) 							# rescale density to the number of occurrences in sp
    # number of occurrence/pixel
    Z<-glob1.dens$y*nrow(glob)/sum(glob1.dens$y) 						# rescale density to the number of sites in glob1
    z[z<max(z)/1000]<-0 										# remove infinitesimally small number generated by kernel density function
    Z[Z<max(Z)/1000]<-0 										# remove infinitesimally small number generated by kernel density function
    
    z.uncor<-z/max(z)											# rescale between [0:1] for comparison with other species
    z<-z/Z												# correct for environment prevalence 
    z[is.na(z)]<-0 											# remove n/0 situations
    z[z=="Inf"]<-0 											# remove 0/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species
    l$x<-x;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp 
  }
  
  if(ncol(glob)==2){ #if scores in two dimensions (e.g. PCA)					
    
    
    library(adehabitat)
    xmin<-min(glob[,1]);xmax<-max(glob[,1]);ymin<-min(glob[,2]);ymax<-max(glob[,2])			# data preparation	
    glob1r<-data.frame(cbind((glob1[,1]-xmin)/abs(xmax-xmin),(glob1[,2]-ymin)/abs(ymax-ymin)))	# data preparation	
    spr<-data.frame(cbind((sp[,1]-xmin)/abs(xmax-xmin),(sp[,2]-ymin)/abs(ymax-ymin))) 			# data preparation
    mask<-ascgen(cbind((1:R)/R,(1:R)/R),nrcol=R,count=F)								# data preparation
    sp.dens<-kernelUD(spr[,1:2],grid=mask,kern="bivnorm")					# calculate the density of occurrences in a grid of RxR pixels along the score gradients
    # using a gaussian kernel density function, with RxR bins.
    sp.dens<-asc2spixdf(sp.dens[[1]]$UD)							# data manipulation																		
    glob1.dens<-kernelUD(glob1r[,1:2],grid=mask,kern="bivnorm")
    glob1.dens<-asc2spixdf(glob1.dens[[1]]$UD)
    x<-seq(from=min(glob[,1]),to=max(glob[,1]),length.out=R)				# breaks on score gradient 1 
    y<-seq(from=min(glob[,2]),to=max(glob[,2]),length.out=R)				# breaks on score gradient 2 
    z<-matrix(sp.dens$var*nrow(sp)/sum(sp.dens$var),nrow=R,ncol=R,byrow=F) 			#rescale density to the number of occurrences in sp
    Z<-matrix(glob1.dens$var*nrow(glob1)/sum(glob1.dens$var),nrow=R,ncol=R,byrow=F) 	#rescale density to the number of sites in glob1
    z[z<max(z)/1000]<-0 											# remove infinitesimally small number generated by kernel density function
    Z[Z<max(Z)/1000]<-0 											# remove infinitesimally small number generated by kernel density function
    
    z.uncor<-z/max(z)											# rescale between [0:1] for comparison with other species	
    z<-z/Z												# correct for environment prevalence
    z[is.na(z)]<-0											# remove n/0 situations
    z[z=="Inf"]<-0											# remove n/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species	
    l$x<-x;l$y<-y;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp
  }
  return(l)
}

##################################################################################################
niche.overlap<-function(z1,z2,cor){ 
  
  # z1 = species 1 occurrence density grid created by grid.clim
  # z2 = species 2 occurrence density grid created by grid.clim
  # cor=T correct occurrence densities of each species by the prevalence of the environments in their range
  
  l<-list()
  
  if(cor==F){		
    p1<-z1$z.uncor/sum(z1$z.uncor) # rescale occurence densities so that the sum of densities is the same for both species
    p2<-z2$z.uncor/sum(z2$z.uncor) # rescale occurence densities so that the sum of densities is the same for both species
  }
  
  if(cor==T){
    p1<-z1$z.cor/sum(z1$z.cor)	# rescale occurence densities so that the sum of densities is the same for both species
    p2<-z2$z.cor/sum(z2$z.cor)	# rescale occurence densities so that the sum of densities is the same for both species
  }
  
  D <-1-(0.5*(sum(abs(p1-p2))))				# overlap metric D
  I <-1-(0.5*(sqrt(sum((sqrt(p1)-sqrt(p2))^2))))	# overlap metric I
  l$D<-D
  l$I<-I
  return(l)
}

##################################################################################################

niche.equivalency.test<-function(z1,z2,rep){
  
  R<-length(z1$x)
  l<-list()
  x11(2,2,pointsize = 12); par(mar=c(0,0,0,0));
  
  obs.o<-niche.overlap(z1,z2,cor=T)									#observed niche overlap
  sim.o<-data.frame(matrix(nrow=rep,ncol=2))							#empty list of random niche overlap
  names(sim.o)<-c("D","I")
  for (i in 1:rep){
    plot.new(); text(0.5,0.5,paste("runs to go:",rep-i+1))
    
    if(is.null(z1$y)){ #overlap on one axis
      
      occ1.sim<-sample(z1$x,size=nrow(z1$sp),replace=T,prob=z1$z.cor) 		#random sampling of occurrences following the corrected densities distribution
      occ2.sim<-sample(z2$x,size=nrow(z2$sp),replace=T,prob=z2$z.cor)
      
      occ.pool<-c(occ1.sim,occ2.sim)   # pool of random occurrences
      rand.row<-sample(1:length(occ.pool),length(occ1.sim),replace=T) 		# random reallocation of occurrences to datasets
      sp1.sim<-occ.pool[rand.row]
      sp2.sim<-occ.pool[-rand.row]
      
      z1.sim<-grid.clim(z1$glob,z1$glob1,data.frame(sp1.sim),R) # gridding
      z2.sim<-grid.clim(z2$glob,z2$glob1,data.frame(sp2.sim),R)	
    }
    
    if(!is.null(z1$y)){ 										#overlap on two axes
      coordinates<-which(z1$z.cor>0,arr.ind=T)						# array of cell coordinates ((1,1),(1,2)...)
      weight<-z1$z.cor[z1$z.cor>0] 								#densities in the same format as cells
      coordinates.sim1<-coordinates[sample(1:nrow(coordinates),size=nrow(z1$sp),replace=T,prob=weight),] #random sampling of coordinates following z1$z.cor distribution
      occ1.sim<-cbind(z1$x[coordinates.sim1[,1]],z1$y[coordinates.sim1[,2]]) 	# random occurrences following the corrected densities distribution
      
      coordinates<-which(z2$z.cor>0,arr.ind=T)						# array of cell coordinates ((1,1),(1,2)...)
      weight<-z2$z.cor[z2$z.cor>0] 								#densities in the same format as cells
      coordinates.sim2<-coordinates[sample(1:nrow(coordinates),size=nrow(z2$sp),replace=T,prob=weight),] #random sampling of coordinates following z1$z.cor distribution
      occ2.sim<-cbind(z2$x[coordinates.sim2[,1]],z2$y[coordinates.sim2[,2]]) 	# random occurrences following the corrected densities distribution
      
      occ.pool<-rbind(occ1.sim,occ2.sim) # pool of random occurrences
      rand.row<-sample(1:nrow(occ.pool),nrow(occ1.sim),replace=T) 			# random reallocation of occurrences to datasets
      sp1.sim<-occ.pool[rand.row,]
      sp2.sim<-occ.pool[-rand.row,]
      
      z1.sim<-grid.clim(z1$glob,z1$glob1,data.frame(sp1.sim),R)
      z2.sim<-grid.clim(z2$glob,z2$glob1,data.frame(sp2.sim),R)	
    }
    
    o.i<-niche.overlap(z1.sim,z2.sim,cor=F)							# overlap between random and observed niches
    sim.o$D[i]<-o.i$D											# storage of overlaps
    sim.o$I[i]<-o.i$I
  }
  
  dev.off()
  l$sim<-sim.o	# storage
  l$obs<-obs.o	# storage
  l$p.D<- min((sum(sim.o$D <= obs.o$D ) + 1),(sum(sim.o$D >= obs.o$D ) + 1))*2/(length(sim.o$D) + 1) 	# storage of p-values
  l$p.I<- min((sum(sim.o$I <= obs.o$I ) + 1),(sum(sim.o$I >= obs.o$I ) + 1))*2/(length(sim.o$I) + 1)	# storage of p-values
  
  return(l)
}

##################################################################################################

niche.similarity.test<-function(z1,z2,rep){
  
  R<-length(z1$x)
  x11(2,2,pointsize = 12); par(mar=c(0,0,0,0));						# countdown window
  l<-list()
  obs.o<-niche.overlap(z1,z2,cor=T) 								#observed niche overlap
  sim.o<-data.frame(matrix(nrow=rep,ncol=2))						#empty list of random niche overlap
  names(sim.o)<-c("D","I")
  
  for (k in 1:rep){
    plot.new(); text(0.5,0.5,paste("similarity tests:","\n","runs to go:",rep-k+1))	# countdown
    
    if(is.null(z2$y)){
      center<-which(z2$z.cor==1,arr.ind=T) 					# define the centroid of the observed niche
      Z<-z2$Z/max(z2$Z)
      rand.center<-sample(1:R,size=1,replace=F,prob=Z)				# randomly (weighted by environment prevalence) define the new centroid for the niche
      
      xshift<-rand.center-center							# shift on x axis
      z2.sim<-z2
      z2.sim$z.cor<-rep(0,R)								# set intial densities to 0
      for(i in 1:R){
        i.trans<-i+xshift
        if(i.trans>R|i.trans<0)next()						# densities falling out of the env space are not considered
        z2.sim$z.cor[i.trans]<-z2$z.cor[i]					# shift of pixels
      }
      z2.sim$z.cor<-(z2$Z!=0)*1*z2.sim$z.cor 					# remove densities out of existing environments
    }
    
    if(!is.null(z2$y)){
      centroid<-which(z2$z.cor==1,arr.ind=T)[1,] 				# define the centroid of the observed niche
      Z<-z2$Z/max(z2$Z)
      rand.centroids<-which(Z>0,arr.ind=T)					# all pixels with existing environments in the study area
      weight<-Z[Z>0]
      rand.centroid<-rand.centroids[sample(1:nrow(rand.centroids)
                                           ,size=1,replace=F,prob=weight),]					# randomly (weighted by environment prevalence) define the new centroid for the niche
      xshift<-rand.centroid[1]-centroid[1]					# shift on x axis
      yshift<-rand.centroid[2]-centroid[2]					# shift on y axis
      z2.sim<-z2
      z2.sim$z.cor<-matrix(rep(0,R*R),ncol=R,nrow=R)				# set intial densities to 0
      for(i in 1:R){
        for(j in 1:R){
          i.trans<-i+xshift
          j.trans<-j+yshift
          if(i.trans>R|i.trans<0)next()					# densities falling out of the env space are not considered
          if(j.trans>R|j.trans<0)next()
          z2.sim$z.cor[i.trans,j.trans]<-z2$z.cor[i,j]		# shift of pixels
        }
      }
      z2.sim$z.cor<-(z2$Z!=0)*1*z2.sim$z.cor 					# remove densities out of existing environments
    }
    o.i<-niche.overlap(z1,z2.sim,cor=T)							# overlap between random and observed niches
    sim.o$D[k]<-o.i$D										# storage of overlaps
    sim.o$I[k]<-o.i$I
  }
  dev.off()
  l$sim<-sim.o											# storage
  l$obs<-obs.o											# storage
  l$p.D<- min((sum(sim.o$D <= obs.o$D ) + 1),(sum(sim.o$D >= obs.o$D ) + 1))*2/(length(sim.o$D) + 1)	# storage of p-values
  l$p.I<- min((sum(sim.o$I <= obs.o$I ) + 1),(sum(sim.o$I >= obs.o$I ) + 1))*2/(length(sim.o$I) + 1)	# storage of p-values
  
  return(l)
}

##################################################################################################

plot.niche<-function(z,title,name.axis1,name.axis2,cor=F){
  
  if(is.null(z$y)){
    R<-length(z$x)
    x<-z$x
    xx<-sort(rep(1:length(x),2))
    
    if(cor==F)y1<-z$z.uncor/max(z$z.uncor)
    if(cor==T)y1<-z$z.cor/max(z$z.cor)
    Y1<-z$Z/max(z$Z)
    yy1<-sort(rep(1:length(y1),2))[-c(1:2,length(y1)*2)]
    YY1<-sort(rep(1:length(Y1),2))[-c(1:2,length(Y1)*2)]
    
    plot(x,y1,type="n",xlab=name.axis1,ylab="density of occurrence")
    polygon(x[xx],c(0,y1[yy1],0,0),col="grey")
    lines(x[xx],c(0,Y1[YY1],0,0))
  }
  
  if(!is.null(z$y)){
    if(cor==F)image(z$x,z$y,z$z.uncor,col = gray(100:0 / 100),zlim=c(0.000001,max(z$z.uncor)),xlab=name.axis1,ylab=name.axis2)
    if(cor==T)image(z$x,z$y,z$z.cor,col = gray(100:0 / 100),zlim=c(0.000001,max(z$z.cor)),xlab=name.axis1,ylab=name.axis2)
    contour(z$x,z$y,z$Z,add=T,levels=quantile(z$Z[z$Z>0],c(0,0.5)),drawlabels=F,lty=c(1,2))
  }
  title(title)
}

plot.contrib<-function(contrib,eigen){
  
  if(ncol(contrib)==1){
    h<-c(unlist(contrib))
    n<-row.names(contrib)
    barplot(h,space=0,names.arg=n)
    title(main="variable contribution")
  }
  if(ncol(contrib)==2){
    s.corcircle(contrib[,1:2]/max(abs(contrib[,1:2])),grid = F)
    title(main="correlation circle", sub=paste("axis1 = ",round(eigen[1]/sum(eigen)*100,2),"%","axis2 = ",round(eigen[2]/sum(eigen)*100,2),"%"))
  }
}


plot.overlap.test<-function (x,type,title) 
{
  if(type=="D") {
    obs <- x$obs$D
    sim <- x$sim$D
    p<-x$p.D
  }
  if(type=="I") {
    obs <- x$obs$I
    sim <- x$sim$I
    p<-x$p.I
  }
  r0 <- c(sim, obs)
  l0 <- max(sim) - min(sim)
  w0 <- l0/(log(length(sim), base = 2) + 1)
  xlim0 <- range(r0) + c(-w0, w0)
  h0 <- hist(sim, plot = FALSE, nclass = 10)
  y0 <- max(h0$counts)
  hist(sim, plot = TRUE, nclass = 10, xlim = xlim0, col = grey(0.8), main= title, xlab=type,sub = paste("p.value = ",round(p,5)))
  lines(c(obs, obs), c(y0/2, 0),col="red")
  points(obs, y0/2, pch = 18, cex = 2,col="red")
  invisible()
}




#################################################################################################
############################## preparation of datasets ##########################################
#################################################################################################

# load climate variable for all site of the study area 1 (column names should be x,y,X1,X2,...,Xn)
clim1<-na.exclude(read.delim("occsO_G.txt",h=T,sep="\t"))
clim1 <- unique(clim1)

# load climate variable for all site of the study area 1 (column names should be x,y,X1,X2,...,Xn)
clim2<-na.exclude(read.delim("occsINV_G.txt",h=T,sep="\t")) 
clim2 <- unique(clim2)

# global climate for both ranges
clim12<-rbind(clim1,clim2)
clim12 <- unique(clim12)

# loading occurrence sites for the species (column names should be x,y)
occ.sp.aggr<- na.exclude(read.delim("occsG.txt",h=T,sep="\t"))
occ.sp.aggr <- unique(occ.sp.aggr)


# remove occurrences closer than a minimum distance to each other (remove aggregation). Setting min.dist=0 will remove no occurrence.
occ.sp<-ecospat.occ.desaggregation(xy=occ.sp.aggr, min.dist=0.1)


newmap <- getMap(resolution = "coarse")
plot(newmap, asp = 1)
points(occ.sp$x, occ.sp$y, 
       col = "salmon", 
       pch = 19, 
       cex = .5)

# create sp occurrence dataset by adding climate variables from the global climate datasets
# resolution should be the resolution of the climate data grid

occ.sp1<-na.exclude(ecospat.sample.envar(dfsp=occ.sp,colspxy=1:2,colspkept=NULL,dfvar=clim1,colvarxy=1:2,colvar="all",resolution=0.16666))
occ.sp2<-na.exclude(ecospat.sample.envar(dfsp=occ.sp,colspxy=1:2,colspkept=NULL,dfvar=clim2,colvarxy=1:2,colvar="all",resolution=0.16666))

# create presence/absence datasets (used in ENFA and SDMs)
row.pa1<-ecospat.sample.envar(dfsp=clim1,colspxy=1:2,colspkept=NULL,dfvar=occ.sp1,colvarxy=1:2,colvar=3,resolution=0) 
#find rows of clim1 where the species is present
pa<-data.frame((!is.na(row.pa1))*1);names(pa)<-"pa" #create 01 column
pa1<-cbind(clim1,pa)

row.pa2<-ecospat.sample.envar(dfsp=clim2,colspxy=1:2,colspkept=NULL,dfvar=occ.sp2,colvarxy=1:2,colvar=3,resolution=0) 
#find rows of clim1 where the species is present
pa<-data.frame((!is.na(row.pa2))*1);names(pa)<-"pa" #create 01 column
pa2<-cbind(clim2,pa)

PROJ = F

# selection of variables to include in the analyses
names(clim12)
Xvar<-c(3:10)
nvar<-length(Xvar)

#number of interation for the tests of equivalency and similarity
iterations<-1000

#resolution of the gridding of the climate space
R=100

row.w.1.occ<-1-(nrow(occ.sp1)/nrow(rbind(occ.sp1,occ.sp2))) # prevalence of occ1
row.w.2.occ<-1-(nrow(occ.sp2)/nrow(rbind(occ.sp1,occ.sp2))) # prevalence of occ2
row.w.occ<-c(rep(0, nrow(clim1)),rep(0, nrow(clim2)),rep(row.w.1.occ, nrow(occ.sp1)),rep(row.w.2.occ, nrow(occ.sp2)))

row.w.1.env<-1-(nrow(clim1)/nrow(clim12))  # prevalence of clim1
row.w.2.env<-1-(nrow(clim2)/nrow(clim12))  # prevalence of clim2
row.w.env<-c(rep(row.w.1.env, nrow(clim1)),rep(row.w.2.env, nrow(clim2)),rep(0, nrow(occ.sp1)),rep(0, nrow(occ.sp2)))

fac<-as.factor(c(rep(1, nrow(clim1)),rep(2, nrow(clim2)),rep(1, nrow(occ.sp1)),rep(2, nrow(occ.sp2))))

# global dataset for the analysis and rows for each sub dataset
data.env.occ<-rbind(clim1,clim2,occ.sp1,occ.sp2)[Xvar]
row.clim1<-1:nrow(clim1)
row.clim2<-(nrow(clim1)+1):(nrow(clim1)+nrow(clim2))
row.clim12<-1:(nrow(clim1)+nrow(clim2))
row.sp1<-(nrow(clim1)+nrow(clim2)+1):(nrow(clim1)+nrow(clim2)+nrow(occ.sp1))
row.sp2<-(nrow(clim1)+nrow(clim2)+nrow(occ.sp1)+1):(nrow(clim1)+nrow(clim2)+nrow(occ.sp1)+nrow(occ.sp2))

nameonevar<-names(clim12)

#################################################################################################
#################################### one-variable ###############################################
#################################################################################################

# measures niche overlap along one chosen variable

onevar<-21 #choose the variable to analyse here
nameonevar<-names(clim12)[onevar]
nameonevar

# predict the scores on the axes
scores.clim12<- data.frame(clim12[,onevar]);names(scores.clim12)<-nameonevar
scores.clim2<- data.frame(clim2[,onevar]);names(scores.clim2)<-nameonevar
scores.clim1<- data.frame(clim1[,onevar]);names(scores.clim1)<-nameonevar
scores.sp2<- data.frame(occ.sp2[,onevar]);names(scores.sp2)<-nameonevar
scores.sp1<- data.frame(occ.sp1[,onevar]);names(scores.sp1)<-nameonevar

# calculation of occurence density and test of niche equivalency and similarity 
z1<- ecospat.grid.clim.dyn(scores.clim12,scores.clim1,scores.sp1,R)
z2<- ecospat.grid.clim.dyn(scores.clim12,scores.clim2,scores.sp2,R)
a<-ecospat.niche.equivalency.test(z1,z2,rep=10)# test of niche equivalency and similarity according to Warren et al. 2008
b<-ecospat.niche.similarity.test(z1,z2,rep=10)
b2<-ecospat.niche.similarity.test(z2,z1,rep=10)

ecospat.plot.niche.dyn(z1, z2, quant=0,interest=2, title= "Niche Overlap", name.axis1="BIO19")




#plot			
x11(); layout(matrix(c(1,1,2,2,1,1,2,2,3,3,4,5,3,3,6,7), 4, 4, byrow = TRUE))
ecospat.plot.niche(z1,title=paste(nameonevar,"- Native niche"),name.axis1="PC1",name.axis2="PC2")
ecospat.plot.niche(z2,title=paste(nameonevar,"- Europe niche"),name.axis1="PC1",name.axis2="PC2")
plot.new()
plot.new(); text(0.5,0.5,paste("niche overlap:","\n","D=",round(as.numeric(ecospat.ecospat.ecospat.niche.overlap(z1,z2,cor=T)[1]),3)))
ecospat.plot.overlap.test(a,"D","Equivalency")
ecospat.plot.overlap.test(b,"D","Similarity 2->1")
ecospat.plot.overlap.test(b2,"D","Similarity 1->2")


t.dyn<-ecospat.niche.dyn.index (z1, z2,
                                intersection=0.1)
ecospat.plot.niche.dyn(z1, z2, quant=0,
                       interest=2, title= "Niche Overlap",
                       name.axis1="Mean Diurnal Range (Mean of monthly (max temp - min temp))")




#################################################################################################
#################################### BIO.PLOT ####################################################
#################################################################################################

#Fer la primera part de l'analisi per extreure sp1, la primera entitat que entra al principi

write.table(occ.sp1, file="C:/R/NicheModelling/DataFinalSA.txt", sep=" ", quote=FALSE, append=FALSE, na="NA")
write.table(occ.sp1, file="C:/R/NicheModelling/DataFinalE", sep=" ", quote=FALSE, append=FALSE, na="NA")
write.table(occ.sp1, file="C:/R/NicheModelling/DataFinalNA", sep=" ", quote=FALSE, append=FALSE, na="NA")
write.table(occ.sp1, file="C:/R/NicheModelling/DataFinalO", sep=" ", quote=FALSE, append=FALSE, na="NA")



install.packages("readr")
library(readr)
install.packages("ggplot2")
install.packages("plyr")
library(plyr)
library(ggplot2)

data.bio <- read_delim("C:/R/NicheModelling/afbrG.txt", 
                       "\t", escape_double = FALSE, trim_ws = TRUE)
data.bio$range<- factor(data.bio$range)
data.bio$cont<- factor(data.bio$cont)

mu <- ddply(data.bio, "cont", summarise, grp.mean=mean(BIO1))
ggplot(data.bio, aes(x=BIO1, color=cont, fill=cont)) +
  geom_histogram(aes(y=..density..), position="identity", alpha=0.2)+
  geom_density(alpha=0.3)+
  geom_vline(data=mu, aes(xintercept=grp.mean, color=cont),
             linetype="dashed")+
  scale_color_manual(values=c("red", "forestgreen", "gray48", "gold"))+
  scale_fill_manual(values=c("red", "forestgreen", "gray48", "gold"))+
  labs(title="Carpobrotus edulis abundance",x="Precipitation of Coldest Quarter", y = "Density")+
  theme_classic()


#BIOs
dens <- kde2d(data.bio$BIO1, data.bio$BIO12, n=300, lims = c(0,210,0,1600))
image(dens)
filled.contour(dens,
               color.palette=colorRampPalette(c('white', 'royalblue4','darkgoldenrod1','brown2')),
               xlab= "Annual Mean Temperature (?C) (x10)",
               ylab= "Annual Precipitation (mm)", main = "Carpobrotus edulis density")


sel <- data.bio$cont == "SouthAfrica"  
inv <- data.bio [sel,]
dens <- kde2d(inv$BIO1, inv$BIO12, n=300, lims = c(0,210,0,1600))
image(dens)
filled.contour(dens,
               color.palette=colorRampPalette(c('white','black','black','black','black','black')),
               xlab= "Annual Mean Temperature (?C) (x10)",
               ylab= "Annual Precipitation (mm)", main = "Carpobrotus edulis density")



sel1 <- data.bio$cont == "Europe"  
sel2 <- data.bio$cont == "NorthAmerica"  
sel3 <- data.bio$cont == "Oceania"  

inv1 <- data.bio [sel1,]
inv2 <- data.bio [sel2,]
inv3 <- data.bio [sel3,]

inv <-rbind(inv1,inv2, inv3)

dens <- kde2d(inv$BIO1, inv$BIO12, n=300, lims = c(0,210,0,1600))
image(dens)
filled.contour(dens,
               color.palette=colorRampPalette(c('white','black','black','black','black','black')),
               xlab= "Annual Mean Temperature (?C) (x10)",
               ylab= "Annual Precipitation (mm)", main = "Carpobrotus edulis density")

